
import os
import random
import pandas as pd
from collections import OrderedDict
from difflib import SequenceMatcher
if __name__ == 'subroutines.extract_coordinates':
    from subroutines.run_stages import run_stages
else:
    from datagen.subroutines.run_stages import run_stages

# Defines dictionary of three- and one-letter codes of the standard 20 amino
# acids
amino_acids_dict = {'ALA': 'A',
                    'ARG': 'R',
                    'ASN': 'N',
                    'ASP': 'D',
                    'CYS': 'C',
                    'GLN': 'Q',
                    'GLU': 'E',
                    'GLY': 'G',
                    'HIS': 'H',
                    'ILE': 'I',
                    'LEU': 'L',
                    'LYS': 'K',
                    'MET': 'M',
                    'PHE': 'F',
                    'PRO': 'P',
                    'SER': 'S',
                    'THR': 'T',
                    'TRP': 'W',
                    'TYR': 'Y',
                    'VAL': 'V'}


class extract_beta_structure_coords(run_stages):

    def __init__(self, run_parameters):
        run_stages.__init__(self, run_parameters)

    def gen_cd_hit_dict(self, cdhit_output, filtered_domain_df):
        # Loads the list of FASTA sequences generated by the CD-HIT web server
        fasta_list = []
        with open(cdhit_output, 'r') as chain_entries_file:
            for seq in chain_entries_file:
                if not seq.startswith(('>', '#')):
                    fasta_list.append(seq.replace('\n', ''))

        # For each of the sequences returned by the CD-HIT web server, selects
        # a random entry from the filtered dataframe of CATH domains from which
        # to select coordinates
        df_index_list = []
        for seq in fasta_list:
            df_index_sub_list = []
            for row in range(filtered_domain_df.shape[0]):
                if seq == filtered_domain_df['DSEQS'][row]:
                    df_index_sub_list.append(row)

            rand_num = random.randint(0, len(df_index_sub_list)-1)
            index = df_index_sub_list[rand_num]
            df_index_list.append(index)

        # Filters dataframe further to retain only the domains selected in the
        # previous step
        cd_hit_domain_df = filtered_domain_df.iloc[df_index_list]
        cd_hit_domain_df = cd_hit_domain_df.reset_index(drop=True)
        return cd_hit_domain_df

    def get_xyz_coords(self, cd_hit_domain_df):
        # Extends the filtered (for resolution, R_factor (working value) and
        # sequence redundancy) dataframe to list the xyz coordinates of each
        # segment sequence (SSEQS)
        all_atoms_dfs_dict = OrderedDict()
        domain_residue_list = []
        unprocessed_list = []

        for row in range(cd_hit_domain_df.shape[0]):
            residue_list = []
            rec = []
            atmnum = []
            atmname = []
            conformer = []
            resname = []
            chain = []
            resnum = []
            insertion = []
            xpos = []
            ypos = []
            zpos = []
            occ = []
            bfac = []
            element = []
            charge = []
            lines = []

            # Copies PDB file of input structure from hard drive
            pdb_code = cd_hit_domain_df['PDB_CODE'][row]

            print('Obtaining ATOM / HETATM records for {}'.format(pdb_code))
            print('{:0.2f}%'.format(((row+1)/cd_hit_domain_df.shape[0])*100))

            middle_characters = pdb_code[1:3]
            cwd = os.getcwd()
            os.chdir('{}{}'.format(self.pdb_database, middle_characters))

            with open('{}.pdb'.format(pdb_code), 'r') as pdb_file:
                pdb_file_lines = [line.strip('\n') for line in pdb_file if
                                  line[0:6].strip() in ['ATOM', 'HETATM', 'TER']]
            pdb_file_lines.append('TER'.ljust(80))

            os.chdir('{}'.format(cwd))

            # For each segment sequence in the domain, makes a list of all
            # sequences in the input PDB file that lie between the recorded
            # start and stop residue numbers and have the same chain id
            for index_1, segment in enumerate(cd_hit_domain_df['SSEQS'][row]):
                sequences = []
                indices = []

                start = cd_hit_domain_df['SSEQS_START_STOP'][row][index_1][0].replace('START=', '')
                stop = cd_hit_domain_df['SSEQS_START_STOP'][row][index_1][1].replace('STOP=', '')
                start_seq = False
                stop_seq = False
                sequence = ''
                index = []

                for index_2, line in enumerate(pdb_file_lines):
                    if index_2 != (len(pdb_file_lines)-1):
                        if (line[22:27].strip() == start
                            and line[21:22] == cd_hit_domain_df['CHAIN'][row]
                            ):
                            start_seq = True

                        if start_seq is True and stop_seq is False:
                            index.append(index_2)
                            if (line[22:27].strip() != pdb_file_lines[index_2+1][22:27].strip()
                                or pdb_file_lines[index_2+1][0:3] == 'TER'
                                ):
                                if line[17:20].strip() in amino_acids_dict:
                                    sequence = sequence + amino_acids_dict[line[17:20].strip()]
                        elif stop_seq is True:
                            sequences.append(sequence)
                            indices.append(index)
                            sequence = ''
                            index = []
                            start_seq = False
                            stop_seq = False
                            continue

                        if (pdb_file_lines[index_2+1][0:3] == 'TER'
                            or (line[22:27].strip() == stop
                                and line[21:22] == cd_hit_domain_df['CHAIN'][row]
                                and pdb_file_lines[index_2+1][22:27].strip() != stop
                                )
                            ):
                                stop_seq = True

                # Selects the first identified sequence from the input PDB that
                # shares greater than 95% sequence similarity with the domain
                # segment sequence in question
                sequence_identified = False
                for index_3, sequence in enumerate(sequences):
                    sseqs_list = []
                    similarity = SequenceMatcher(a=segment, b=sequence).ratio()
                    if similarity >= 0.95:
                        sequence_identified = True

                        pdb_file = open('Entire_domains/{}.pdb'.format(
                            cd_hit_domain_df['DOMAIN_ID'][row]), 'a')

                        for index_4 in indices[index_3]:
                            sseqs_list.append(pdb_file_lines[index_4][21:27].replace(' ', ''))

                            pdb_file.write('{}\n'.format(pdb_file_lines[index_4]))

                            rec.append(pdb_file_lines[index_4][0:6].strip())
                            atmnum.append(int(pdb_file_lines[index_4][6:11].strip()))
                            atmname.append(pdb_file_lines[index_4][12:16].strip())
                            conformer.append(pdb_file_lines[index_4][16:17].strip())
                            resname.append(pdb_file_lines[index_4][17:20].strip())
                            chain.append(pdb_file_lines[index_4][21:22].strip())
                            resnum.append(int(pdb_file_lines[index_4][22:26].strip()))
                            insertion.append(pdb_file_lines[index_4][26:27].strip())
                            xpos.append(float(pdb_file_lines[index_4][30:38].strip()))
                            ypos.append(float(pdb_file_lines[index_4][38:46].strip()))
                            zpos.append(float(pdb_file_lines[index_4][46:54].strip()))
                            occ.append(float(pdb_file_lines[index_4][54:60].strip()))
                            bfac.append(float(pdb_file_lines[index_4][60:66].strip()))
                            element.append(pdb_file_lines[index_4][76:78].strip())
                            charge.append(pdb_file_lines[index_4][78:80].strip())
                            lines.append(pdb_file_lines[index_4])

                        pdb_file.write('TER'.ljust(80)+'\n')
                        pdb_file.close()

                        residue_list.extend(sseqs_list)
                        break

                if sequence_identified is False:
                    unprocessed_list.append('{}'.format(cd_hit_domain_df['DOMAIN_ID'][row]))
                    break

            # Makes a dataframe of the PDB information for the domain sequence
            # if each of its SSEQS were identified in the input PDB file
            if not cd_hit_domain_df['DOMAIN_ID'][row] in unprocessed_list:
                pdb_df = pd.DataFrame({'FILE_LINES': lines,
                                       'REC': rec,
                                       'ATMNUM': atmnum,
                                       'ATMNAME': atmname,
                                       'CONFORMER': conformer,
                                       'RESNAME': resname,
                                       'CHAIN': chain,
                                       'RESNUM': resnum,
                                       'INSCODE': insertion,
                                       'XPOS': xpos,
                                       'YPOS': ypos,
                                       'ZPOS': zpos,
                                       'OCC': occ,
                                       'BFAC': bfac,
                                       'ELEMENT': element,
                                       'CHARGE': charge})
                cols = pdb_df.columns.tolist()
                cols = ([cols[7]] + [cols[10]] + [cols[1]] + [cols[0]]
                        + [cols[5]] + [cols[11]] + [cols[3]] + [cols[12]]
                        + [cols[8]] + [cols[13]] + [cols[14]] + [cols[15]]
                        + [cols[9]] + [cols[2]] + [cols[6]] + [cols[4]])
                pdb_df = pdb_df[cols]
                all_atoms_dfs_dict[cd_hit_domain_df['DOMAIN_ID'][row]] = pdb_df

            # Makes a list of residue numbers of the domain sequence if
            # successfully identified in the input PDB file
            chain_num_list = []
            for chain_num in residue_list:
                if chain_num not in chain_num_list:
                    chain_num_list.append(chain_num)
            if not cd_hit_domain_df['DOMAIN_ID'][row] in unprocessed_list:
                domain_residue_list.append(chain_num_list)

        # Lists all segment sequences that could not be processed owing to
        # insufficient similarity between the FASTA sequence listed in the
        # CATH_domain_desc_v_4_2_0.txt and the FASTA sequence extracted from
        # the PDB file in the unprocessed structures file
        with open('Unprocessed_domains.txt', 'a') as unprocessed_file:
            unprocessed_file.write('\n\n{} domain unable to be identified in '
                                   'PDB file:\n'.format(self.code))
            for domain_id in set(unprocessed_list):
                unprocessed_file.write('{}\n'.format(domain_id))

        cd_hit_domain_df = cd_hit_domain_df[~cd_hit_domain_df['DOMAIN_ID'].isin(unprocessed_list)]
        cd_hit_domain_df = cd_hit_domain_df.reset_index(drop=True)

        # Appends column of residue numbers to the input dataframe
        domain_residue_df = pd.DataFrame({'CHAIN_NUM': domain_residue_list})
        cd_hit_domain_df = pd.concat([cd_hit_domain_df, domain_residue_df], axis=1)

        return cd_hit_domain_df, all_atoms_dfs_dict
